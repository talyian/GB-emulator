<!DOCTYPE html>
<style>
  body { background:#333; }
  #tile0 { width:128px; height:64px; }
  #bg { width:256px; height: 256px; }
  #cvscreen {
      width:320px;
      height:288px;
      border:1px solid green;
  }
  /* copied from https://stackoverflow.com/questions/7615009 */
  canvas {
      image-rendering: optimizeSpeed;             /* Older versions of FF          */
      image-rendering: -moz-crisp-edges;          /* FF 6.0+                       */
      image-rendering: -webkit-optimize-contrast; /* Safari                        */
      image-rendering: -o-crisp-edges;            /* OS X & Windows Opera (12.02+) */
      image-rendering: pixelated;                 /* Awesome future-browsers       */
      -ms-interpolation-mode: nearest-neighbor;   /* IE                            */
  }
</style>


<canvas id=cvscreen width=160 height=144 style='background:#edf'> </canvas>
<!--Background map preview - 32x32 tiles * 8x8 tile size = 256 * 256 -->
<canvas id=bg width=256 height=256 style='background:#def'> </canvas>
<!--Tile map preview: 16 * 8 tiles each at 8*8-->
<canvas id=tile0 width=128 height=64 style='background:#fed'> </canvas> 
<canvas id=tile1 width=128 height=64 style='background:#fed'> </canvas>
<canvas id=tile2 width=128 height=64 style='background:#fed'> </canvas>

<script>
  if (typeof TextDecoder == "undefined") {
    function TextDecoder() {  }
    TextDecoder.prototype.decode = function (arr) {
      return String.fromCharCode.apply(null, new Uint8Array(arr));
    }
  }

  var emulator = 0, frames = 0;
  var instance, line=[], dec = new TextDecoder();
  var memory = new WebAssembly.Memory({ initial: 32 });
  function draw_display(canvas, data) {
    frames++;
    var p = 0, i = 0;
    var image_buffer = canvas._buffer;
    var ctx = canvas.getContext("2d");
    if (!image_buffer)
      image_buffer = canvas._buffer = ctx.createImageData(160, 144);
    var H = 144, W = 160;
    var idata = image_buffer.data, j = 0;
    for(var y = 0; y < H; y++) {
      for(var x = 0; x < W; x++) {
        p = data[i++];
        idata[j++] = p * 80;
        idata[j++] = p * 80;
        idata[j++] = p / 2 ? 0 : 255;
        idata[j++] = 255;
      }
    }
    ctx.putImageData(image_buffer, 0, 0);
  }
  // setInterval(function() {
  //   console.log("frames / sec", frames);
  //   frames = 0;
  // }, 1000);
  function draw_vram(canvas, data) {
    var ctx = canvas.getContext("2d");
    var image_buffer = canvas._buffer;
    if (!image_buffer)
      image_buffer = canvas._buffer = ctx.createImageData(canvas.width, canvas.height);
    
    var idata = image_buffer.data, k = 0;
    var w = 8, tile_idx = 0, tile_number = 0;
    // 0x800 bytes, 0x80 sprites, so each one takes up 0x10 bytes
    for(var y = 0; y < 8; y++) {
      for(var x = 0; x < 16; x++) {
        tile_number++;
        for(var j = 0; j < 8; j++) {
          var b0 = data[tile_idx++];
          var b1 = data[tile_idx++];
          var w0 = b0 * 0x100 + b1;
          for(var i = 0; i < 8; i++) {
            var p = (w0 >> (15 - i)) & 0x1;
            p = p << 1;
            var q = (w0 >> (7 - i)) & 0x1;
            p = p | q;
            k = 4 * ((y * 8 + j) * canvas.width + x * 8 + i);
            idata[k++] = p * 80;
            idata[k++] = p * 80;
            idata[k++] = p / 2 ? 0 : 255;
            idata[k++] = 255;
          }
        }
      }
    }
    ctx.putImageData(image_buffer, 0, 0);
  }
  
  function push_frame(category, data, len) {
    var buf = new Uint8Array(memory.buffer.slice(data, data + len));
    if (category == 0x100) { // tile data
      draw_vram(tile0, buf);
    }
    if (category == 0x101) { // tile data
      draw_vram(tile1, buf);
    }
    if (category == 0x102) { // tile data
      draw_vram(tile2, buf);
    }
    if (category == 0x300) { // tile data
      draw_display(cvscreen, buf, len);
    }
    if (category == 0x200) { // background
      var ctx = bg.getContext("2d");
      var image_buffer = bg._buffer, k = 0;
      var ctx = bg.getContext("2d");
      if (!image_buffer)
        image_buffer = bg._buffer = ctx.createImageData(160, 144);
      var idata = image_buffer.data;
      var w = 8, i = 0, cc = {};
      for(var y = 0; y < 32; y++) {
        for(var x = 0; x < 32; x++) {
          for(var i = 0; i < 8; i++) {
            for(var j = 0; j < 8; j++) {

            }
          }
          // ctx.fillStyle = ['red', 'blue','green', 'pink'][buf[i++] % 4]
          // ctx.fillRect(x * w, y * w, w, w);
          var p = buf[i++] % 4;
          idata[k++] = p * 80;
          idata[k++] = p * 80;
          idata[k++] = p / 2 ? 0 : 255;
          idata[k++] = 255;
        }
      }
      ctx.putImageData(image_buffer, 0, 0);
    }
  }
  var error = 0;
  var env = {
    _test: function(foobar) { console.log(foobar); },
    _logf: function(f) { line.push(f); },
    _logx8: function(f) { line.push(('00' + f.toString(16)).substr(-2)); },
    _logx16: function(f) { line.push(('0000' + f.toString(16)).substr(-4)); },
    _logx32: function(f) { line.push(f.toString(16)); },
    _logs: function(i, len) {
      if (!len) { line.push(i.toString(16)); return; }
      line.push(dec.decode(memory.buffer.slice(i, i + len)));
    },
    _showlog: function() { console.log.apply(console, line); line = []; },
    _push_frame: push_frame,
    _stop: function() { error = 1; },
    _check_memory_size: function () { 
      console.log(
        'byte size', memory.buffer.byteLength,
        'page size', memory.buffer.byteLength / 64 / 1024);
    },
    memory:memory,
  };
  fetch("build/gb_emulator.wasm")
  .then((resp) => resp.arrayBuffer())
  .then((wasm) => WebAssembly.instantiate(wasm, { env: env }))
  .then((module) => {
    instance = module.instance;

    emulator = instance.exports.get_emulator();

    requestAnimationFrame(function loop() {
      instance.exports.step_frame(emulator);
      if (!error) requestAnimationFrame(loop);
    });
  });
</script>
